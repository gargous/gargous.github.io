<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Garg</title>
  
  <subtitle>Garg Blog</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-11-21T20:18:07.078Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>石像</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>windows开发吃豆人——角色</title>
    <link href="http://example.com/2021/11/16/win-pac-man-3/"/>
    <id>http://example.com/2021/11/16/win-pac-man-3/</id>
    <published>2021-11-16T15:38:03.322Z</published>
    <updated>2021-11-21T20:18:07.078Z</updated>
    
    <content type="html"><![CDATA[<h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>首先需要一张角色图</p><img src="/2021/11/16/win-pac-man-3/actors.png" class="" width="200" height="200" title="actors"><p>因为需要用到windows的cpp库需要修改为cpp文件</p><img src="/2021/11/16/win-pac-man-3/cpp.png" class="" title="cpp"><p>因为cpp的原因有一些库需要声明引用，比如time</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;AtlImage.h&gt;</span></span></span><br></pre></td></tr></table></figure><hr><h4 id="初始化角色"><a href="#初始化角色" class="headerlink" title="初始化角色"></a>初始化角色</h4><p>首先定义角色结构</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Actor</span> &#123;</span></span><br><span class="line">POINT Pos; <span class="comment">//位置</span></span><br><span class="line">POINT Size; <span class="comment">// 大小</span></span><br><span class="line">CImage* Img; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Actor</span> <span class="title">actors</span>[<span class="title">ACTOR_MAX_CNT</span>];</span></span><br></pre></td></tr></table></figure><p>一个角色需要的绘制的是整张图片的部分区域所以需要ImgSliceRects做划分，而且因为我们使用的角色图片没有颜色，所以需要ColorBrush对其进行染色。<br>这里为了方便读取png图片，用到了CImage和CRect均是mfc库来自AtlImage.h，一般windows编程中C打头的都是mfc库。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Actor <span class="title">InitActor</span><span class="params">(CImage* actorsImg, <span class="keyword">int</span> row, <span class="keyword">int</span> rowSize, <span class="keyword">int</span> colSize, COLORREF color)</span> </span>&#123;</span><br><span class="line">CImage* actorImg = <span class="keyword">new</span> <span class="built_in">CImage</span>();</span><br><span class="line">actorImg-&gt;<span class="built_in">Create</span>(actorsImg-&gt;<span class="built_in">GetWidth</span>(), colSize, actorsImg-&gt;<span class="built_in">GetBPP</span>(), <span class="number">1</span>); <span class="comment">//32位图最后一个参数填1</span></span><br><span class="line">actorImg-&gt;<span class="built_in">SetHasAlphaChannel</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> y = row * colSize; y &lt; (row + <span class="number">1</span>) * colSize; y++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; actorsImg-&gt;<span class="built_in">GetWidth</span>(); x++) &#123;</span><br><span class="line"><span class="keyword">int</span> relx = x;</span><br><span class="line"><span class="keyword">int</span> rely = y - row * colSize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* oldColor = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>*&gt;(actorsImg-&gt;<span class="built_in">GetPixelAddress</span>(x, y));</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* newColor = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>*&gt;(actorImg-&gt;<span class="built_in">GetPixelAddress</span>(relx, rely));</span><br><span class="line"></span><br><span class="line"><span class="comment">//全部拷贝</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">newColor[i] = oldColor[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//非黑白区域染色</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> r = oldColor[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> g = oldColor[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> b = oldColor[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">if</span> (!((r == <span class="number">0</span> &amp;&amp; g == <span class="number">0</span> &amp;&amp; b == <span class="number">0</span>) || (r == <span class="number">255</span> &amp;&amp; g == <span class="number">255</span> &amp;&amp; b == <span class="number">255</span>))) &#123; <span class="comment">//不是黑白</span></span><br><span class="line">newColor[<span class="number">0</span>] = oldColor[<span class="number">0</span>] * <span class="built_in">GetRValue</span>(color) / <span class="number">255</span>;</span><br><span class="line">newColor[<span class="number">1</span>] = oldColor[<span class="number">1</span>] * <span class="built_in">GetGValue</span>(color) / <span class="number">255</span>;</span><br><span class="line">newColor[<span class="number">2</span>] = oldColor[<span class="number">2</span>] * <span class="built_in">GetBValue</span>(color) / <span class="number">255</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Actor actor;</span><br><span class="line">actor.Img = actorImg;</span><br><span class="line">actor.Size = POINT&#123; TILE_SIZE, TILE_SIZE &#125;;</span><br><span class="line"><span class="keyword">return</span> actor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要注意CImage的load需要使用指针操作，因为他的拷贝和析构都做了特殊处理，这里如果使用结构体赋予给actors的时候就会触发一些我们不太希望出现的情况。<br>这里我们实现给图片进行切割，因为每个角色是占了一横排，所以截取其中一行，然后对这一行的进行染色。<br>GetPixelAddress可以取出对应位置的颜色值，0-4分别是红绿蓝透明，染色方法使用了相乘算法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">InitActors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">CImage* actorsImg = <span class="keyword">new</span> <span class="built_in">CImage</span>();</span><br><span class="line">actorsImg-&gt;<span class="built_in">Load</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;./actors.png&quot;</span>));</span><br><span class="line">actors[<span class="number">0</span>] = <span class="built_in">InitActor</span>(actorsImg, <span class="number">0</span>, <span class="number">20</span>, <span class="number">20</span>, <span class="built_in">RGB</span>(<span class="number">105</span>, <span class="number">215</span>, <span class="number">255</span>));</span><br><span class="line">actors[<span class="number">0</span>].Pos = POINT&#123; TILE_SIZE, TILE_SIZE&#125;;</span><br><span class="line">actors[<span class="number">1</span>] = <span class="built_in">InitActor</span>(actorsImg, <span class="number">2</span>, <span class="number">20</span>, <span class="number">20</span>, <span class="built_in">RGB</span>(<span class="number">105</span>, <span class="number">215</span>, <span class="number">255</span>));</span><br><span class="line">actors[<span class="number">1</span>].Pos = POINT&#123; TILE_SIZE, TILE_SIZE * <span class="number">2</span> &#125;;</span><br><span class="line">actors[<span class="number">2</span>] = <span class="built_in">InitActor</span>(actorsImg, <span class="number">1</span>, <span class="number">20</span>, <span class="number">20</span>, <span class="built_in">RGB</span>(<span class="number">255</span>, <span class="number">170</span>, <span class="number">60</span>));</span><br><span class="line">actors[<span class="number">2</span>].Pos = POINT&#123; TILE_SIZE, TILE_SIZE * <span class="number">3</span> &#125;;</span><br><span class="line">actors[<span class="number">3</span>] = <span class="built_in">InitActor</span>(actorsImg, <span class="number">1</span>, <span class="number">20</span>, <span class="number">20</span>, <span class="built_in">RGB</span>(<span class="number">255</span>, <span class="number">110</span>, <span class="number">255</span>));</span><br><span class="line">actors[<span class="number">3</span>].Pos = POINT&#123; TILE_SIZE, TILE_SIZE * <span class="number">4</span> &#125;;</span><br><span class="line">actors[<span class="number">4</span>] = <span class="built_in">InitActor</span>(actorsImg, <span class="number">1</span>, <span class="number">20</span>, <span class="number">20</span>, <span class="built_in">RGB</span>(<span class="number">110</span>, <span class="number">160</span>, <span class="number">255</span>));</span><br><span class="line">actors[<span class="number">4</span>].Pos = POINT&#123; TILE_SIZE, TILE_SIZE * <span class="number">5</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后初始化5个角色。</p><hr><h4 id="绘制角色"><a href="#绘制角色" class="headerlink" title="绘制角色"></a>绘制角色</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">DrawActors</span><span class="params">(HDC hdc)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ACTOR_MAX_CNT; i++) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Actor</span> <span class="title">actor</span> =</span> actors[i];</span><br><span class="line"><span class="keyword">if</span> (!actor.Img) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (actor.Img-&gt;<span class="built_in">IsNull</span>()) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">CRect dstRect = <span class="built_in">CRect</span>(actor.Pos.x, actor.Pos.y, actor.Pos.x + actor.Size.x, actor.Pos.y + actor.Size.y);</span><br><span class="line">actor.Img-&gt;<span class="built_in">Draw</span>(hdc, dstRect);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时调整一下调用者将BeginPaint和EndPaint放在最外边</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_PAINT:</span><br><span class="line">PAINTSTRUCT ps;</span><br><span class="line">HDC hdc;</span><br><span class="line">hdc = <span class="built_in">BeginPaint</span>(hWnd, &amp;ps);</span><br><span class="line"><span class="built_in">DrawTiles</span>(hdc);</span><br><span class="line"><span class="built_in">DrawActors</span>(hdc);</span><br><span class="line"><span class="built_in">EndPaint</span>(hWnd, &amp;ps);</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>运行发现图片已经显示</p><img src="/2021/11/16/win-pac-man-3/draw1.png" class="" width="200" title="draw1"><p>这时候需要对图片进行切片，多个切片是为了后面做动画，给actor加入新字段</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Actor</span> &#123;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">int</span> AnimSliceOffset;</span><br><span class="line"><span class="keyword">int</span> AnimSliceMax;</span><br><span class="line"><span class="keyword">int</span> AnimSliceIndex;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>同时给其赋予初始值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Actor <span class="title">InitActor</span><span class="params">(CImage* actorsImg, <span class="keyword">int</span> row, <span class="keyword">int</span> rowSize, <span class="keyword">int</span> colSize, <span class="keyword">int</span> animSliceMax, COLORREF color)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">actor.AnimSliceIndex = <span class="number">0</span>;</span><br><span class="line">actor.AnimSliceOffset = rowSize;</span><br><span class="line">actor.AnimSliceMax = animSliceMax;</span><br><span class="line"><span class="keyword">return</span> actor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改每个角色的animSliceMax，因为食物角色没有动画就是1，其余都是3</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">InitActors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">actors[<span class="number">0</span>] = <span class="built_in">InitActor</span>(actorsImg, <span class="number">0</span>, <span class="number">20</span>, <span class="number">20</span>, <span class="number">3</span>, <span class="built_in">RGB</span>(<span class="number">105</span>, <span class="number">215</span>, <span class="number">255</span>));</span><br><span class="line">...</span><br><span class="line">actors[<span class="number">1</span>] = <span class="built_in">InitActor</span>(actorsImg, <span class="number">2</span>, <span class="number">20</span>, <span class="number">20</span>, <span class="number">1</span>, <span class="built_in">RGB</span>(<span class="number">105</span>, <span class="number">215</span>, <span class="number">255</span>));</span><br><span class="line">...</span><br><span class="line">actors[<span class="number">2</span>] = <span class="built_in">InitActor</span>(actorsImg, <span class="number">1</span>, <span class="number">20</span>, <span class="number">20</span>, <span class="number">3</span>, <span class="built_in">RGB</span>(<span class="number">255</span>, <span class="number">170</span>, <span class="number">60</span>));</span><br><span class="line">...</span><br><span class="line">actors[<span class="number">3</span>] = <span class="built_in">InitActor</span>(actorsImg, <span class="number">1</span>, <span class="number">20</span>, <span class="number">20</span>, <span class="number">3</span>, <span class="built_in">RGB</span>(<span class="number">255</span>, <span class="number">110</span>, <span class="number">255</span>));</span><br><span class="line">...</span><br><span class="line">actors[<span class="number">4</span>] = <span class="built_in">InitActor</span>(actorsImg, <span class="number">1</span>, <span class="number">20</span>, <span class="number">20</span>, <span class="number">3</span>, <span class="built_in">RGB</span>(<span class="number">110</span>, <span class="number">160</span>, <span class="number">255</span>));</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StretchBlt可以拉升和切割图片到指定位置和大小</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">DrawActors</span><span class="params">(HDC hdc)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ACTOR_MAX_CNT; i++) &#123;</span><br><span class="line">CRect dstRect = <span class="built_in">CRect</span>(actor.Pos.x, actor.Pos.y, actor.Pos.x + actor.Size.x, actor.Pos.y + actor.Size.y);</span><br><span class="line">CRect srcRect = <span class="built_in">CRect</span>(actor.AnimSliceIndex * actor.AnimSliceOffset, <span class="number">0</span>, (actor.AnimSliceIndex + <span class="number">1</span>) * actor.AnimSliceOffset, actor.Img-&gt;<span class="built_in">GetHeight</span>());</span><br><span class="line">actor.Img-&gt;<span class="built_in">StretchBlt</span>(hdc, dstRect, srcRect);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们把draw换成StretchBlt</p><img src="/2021/11/16/win-pac-man-3/draw2.png" class="" width="200" title="draw2"><p>发现图片有明显的白色包边，而且透明的部分并没有透明。<br>这是因为Draw方法内部并不是简单的调用StretchBlt，而是更具图像是否有透明通道使用了AlphaBlend，其可以绘制出有透明区域的图片。<br>首先初始化一个默认值的BLENDFUNCTION，这里图片因为是32位的所以使用AlphaFormat = 1</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BLENDFUNCTION fnc;</span><br><span class="line">fnc.BlendOp = AC_SRC_OVER;</span><br><span class="line">fnc.BlendFlags = <span class="number">0</span>;</span><br><span class="line">fnc.SourceConstantAlpha = <span class="number">255</span>; <span class="comment">//原图的透明度0-255</span></span><br><span class="line">fnc.AlphaFormat = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>然后把StretchBlt换成AlphaBlend</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">DrawActors</span><span class="params">(HDC hdc)</span> </span>&#123;</span><br><span class="line">BLENDFUNCTION fnc;</span><br><span class="line">fnc.BlendOp = AC_SRC_OVER;</span><br><span class="line">fnc.BlendFlags = <span class="number">0</span>;</span><br><span class="line">fnc.SourceConstantAlpha = <span class="number">255</span>;</span><br><span class="line">fnc.AlphaFormat = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ACTOR_MAX_CNT; i++) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Actor</span> <span class="title">actor</span> =</span> actors[i];</span><br><span class="line"><span class="keyword">if</span> (!actor.Img) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (actor.Img-&gt;<span class="built_in">IsNull</span>()) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CRect dstRect = <span class="built_in">CRect</span>(actor.Pos.x, actor.Pos.y, actor.Pos.x + actor.Size.x, actor.Pos.y + actor.Size.y);</span><br><span class="line">CRect srcRect = <span class="built_in">CRect</span>(actor.AnimSliceIndex * actor.AnimSliceOffset, <span class="number">0</span>, (actor.AnimSliceIndex + <span class="number">1</span>) * actor.AnimSliceOffset, actor.Img-&gt;<span class="built_in">GetHeight</span>());</span><br><span class="line"></span><br><span class="line"><span class="built_in">AlphaBlend</span>(hdc, dstRect.left, dstRect.top, dstRect.<span class="built_in">Width</span>(), dstRect.<span class="built_in">Height</span>(),</span><br><span class="line">actor.Img-&gt;<span class="built_in">GetDC</span>(), srcRect.left, srcRect.top, srcRect.<span class="built_in">Width</span>(), srcRect.<span class="built_in">Height</span>(), fnc);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2021/11/16/win-pac-man-3/draw3.png" class="" width="200" title="draw3"><hr><h4 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h4><p>windows程序一般使用定时器驱动动画</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SetTimer</span>(HWND 窗口句柄, UINT_PTR 事件ID, UINT 时间间隔(毫秒), TIMERPROC 处理函数);</span><br></pre></td></tr></table></figure><p>因为窗口创建后WndProc会触发WM_CREATE事件，我们把之前的初始化的几个函数转移一下位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in"><span class="keyword">switch</span></span> (message)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> WM_CREATE:</span><br><span class="line"><span class="built_in">srand</span>((<span class="keyword">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line"><span class="built_in">InitTiles</span>();</span><br><span class="line"><span class="built_in">InitActors</span>();</span><br><span class="line"><span class="built_in">SetTimer</span>(hWnd, <span class="number">1</span>, <span class="number">100</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们设置timer的事件是大于0的整数即可，处理函数填空会使用窗口的默认接受函数即WndProc</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in"><span class="keyword">switch</span></span> (message)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">case</span> WM_CREATE:</span><br><span class="line"><span class="built_in">srand</span>((<span class="keyword">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line"><span class="built_in">InitTiles</span>();</span><br><span class="line"><span class="built_in">InitActors</span>();</span><br><span class="line"><span class="built_in">SetTimer</span>(hWnd, <span class="number">1</span>, <span class="number">100</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们需要timer到了更新所有角色的动画</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">UpdateActors</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ACTOR_MAX_CNT; i++)&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Actor</span> <span class="title">actor</span> =</span> actors[i];</span><br><span class="line"><span class="keyword">if</span> (!actor.Img) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (actor.Img-&gt;<span class="built_in">IsNull</span>()) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">actors[i].AnimSliceIndex = (actor.AnimSliceIndex + <span class="number">1</span>) % actor.AnimSliceMax;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>timer到了后会向WndProc发送WM_TIMER事件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in"><span class="keyword">switch</span></span> (message)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">case</span> WM_TIMER:</span><br><span class="line"><span class="built_in">UpdateActors</span>();</span><br><span class="line"><span class="built_in">InvalidateRect</span>(hWnd, <span class="literal">NULL</span>, TRUE);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里InvalidateRect会触发一次刷新窗口，第三个参数TRUE表示会清空窗口，同时WndProc会收到WM_PAINT进行重绘。</p><iframe width=200 src="./draw4.gif" scrolling="no" frameborder="0"></iframe><p>发现包边又出现了，而且时有时无像闪烁一般。<br>这是因为我们绘制的时候是分别绘制，而显卡读取图像的内容的时间是不定的所以如果多次使用bitblt一类的函数绘制给全局dc就会出现绘制不全的问题。<br>解决方法就是先绘制给一个缓存dc上，再一次全部绘制给全局dc。<br>我们可以修改Paint部分的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in"><span class="keyword">switch</span></span> (message)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">case</span> WM_PAINT: &#123;</span><br><span class="line">PAINTSTRUCT ps;</span><br><span class="line">HDC hdc = <span class="built_in">BeginPaint</span>(hWnd, &amp;ps);</span><br><span class="line"></span><br><span class="line">CRect clientRect;</span><br><span class="line">HDC hCacheDC;</span><br><span class="line">HBITMAP hCacheBitmap;</span><br><span class="line"></span><br><span class="line"><span class="built_in">GetWindowRect</span>(hWnd, &amp;clientRect);</span><br><span class="line">hCacheDC = <span class="built_in">CreateCompatibleDC</span>(hdc);</span><br><span class="line">hCacheBitmap = <span class="built_in">CreateCompatibleBitmap</span>(hdc, clientRect.<span class="built_in">Width</span>(), clientRect.<span class="built_in">Height</span>());</span><br><span class="line"><span class="built_in">SelectObject</span>(hCacheDC, hCacheBitmap);</span><br><span class="line"></span><br><span class="line"><span class="built_in">DrawTiles</span>(hCacheDC);</span><br><span class="line"><span class="built_in">DrawActors</span>(hCacheDC);</span><br><span class="line"></span><br><span class="line"><span class="built_in">BitBlt</span>(hdc, <span class="number">0</span>, <span class="number">0</span>, clientRect.<span class="built_in">Width</span>(), clientRect.<span class="built_in">Height</span>(), hCacheDC, <span class="number">0</span>, <span class="number">0</span>, SRCCOPY);</span><br><span class="line"><span class="built_in">DeleteObject</span>(hCacheDC);</span><br><span class="line"><span class="built_in">DeleteObject</span>(hCacheBitmap);</span><br><span class="line"></span><br><span class="line"><span class="built_in">EndPaint</span>(hWnd, &amp;ps);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><iframe width=300 src="./draw5.gif" scrolling="no" frameborder="0"></iframe>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h4&gt;&lt;p&gt;首先需要一张角色图&lt;/p&gt;
&lt;img src=&quot;/2021/11/16/win-pac-man-3/actors.png&quot; </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>windows开发吃豆人——场景</title>
    <link href="http://example.com/2021/11/03/win-pac-man-2/"/>
    <id>http://example.com/2021/11/03/win-pac-man-2/</id>
    <published>2021-11-03T06:26:21.571Z</published>
    <updated>2021-11-03T08:11:55.779Z</updated>
    
    <content type="html"><![CDATA[<h4 id="定义地图结构"><a href="#定义地图结构" class="headerlink" title="定义地图结构"></a>定义地图结构</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TITLE_TYPE_CNT 6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TILE_W 31</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TILE_H 29</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Region</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">HRGN hrgn;</span><br><span class="line">HBRUSH hBrush;</span><br><span class="line">BOOL fill;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Tiles</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> Grids[TILE_H][TILE_W]; <span class="comment">//逻辑单元</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Region</span> <span class="title">Regions</span>[<span class="title">TITLE_TYPE_CNT</span>];</span> <span class="comment">//绘制单元</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tiles</span> <span class="title">tiles</span>;</span> <span class="comment">//初始化一个全局Tiles</span></span><br></pre></td></tr></table></figure><p>这里用到了HRGN和HBRUSH这两个结构是标准库中的区域于画笔，类似photoshop里面的选区和笔刷。</p><hr><h4 id="地图绘制"><a href="#地图绘制" class="headerlink" title="地图绘制"></a>地图绘制</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">DrawTiles</span><span class="params">(HWND hWnd)</span> </span>&#123;</span><br><span class="line">PAINTSTRUCT ps;</span><br><span class="line">HDC hdc;</span><br><span class="line">hdc = BeginPaint(hWnd, &amp;ps);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; TITLE_TYPE_CNT; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (tiles.Regions[i].hrgn == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (tiles.Regions[i].fill) &#123;</span><br><span class="line">FillRgn(hdc, tiles.Regions[i].hrgn, tiles.Regions[i].hBrush);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">FrameRgn(hdc, tiles.Regions[i].hrgn, tiles.Regions[i].hBrush, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">EndPaint(hWnd, &amp;ps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里用到了FillRgn和FrameRgn这两个函数用来填充区域以及对区域描边<br>注意HBRUSH和HRGN是被定义成指针结构的宏所以可以使用于NULL值的比较判断</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (message)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> WM_PAINT:</span><br><span class="line">DrawTiles(hWnd);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">PostQuitMessage(<span class="number">0</span>); <span class="comment">//点击关闭按钮会退出程序</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> DefWindowProc(hWnd, message, wParam, lParam);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改WndProc的回调内容，其中WM_PAINT作为一种消息会通过一些复杂的机制传入，比如初始化窗口，缩放窗口都会触发，这里调用我们之前写的DrawTiles就可以完成绘制。<br>此时运行程序什么也没有，因为tiles并没有填入数据。</p><img src="/2021/11/03/win-pac-man-2/empty.png" class="" title="empty"><hr><h4 id="地图数据初始化"><a href="#地图数据初始化" class="headerlink" title="地图数据初始化"></a>地图数据初始化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TITLE_TYPE_EMP 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TITLE_TYPE_WALL 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TITLE_TYPE_FRAME 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TITLE_TYPE_DOOR 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TITLE_TYPE_ENEMY 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TITLE_TYPE_PRORECTED 5 <span class="comment">//保护区域与TITLE_TYPE_EMP逻辑一致主要为了后续填块与其做区分</span></span></span><br><span class="line"><span class="function">VOID <span class="title">InitTilesStatic</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; TILE_H; col++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; TILE_W; row++) &#123;</span><br><span class="line"><span class="keyword">int</span> grid = TITLE_TYPE_EMP;</span><br><span class="line">grid = MakeTilesOutlineGrid(col, row, grid);</span><br><span class="line">grid = MakeTilesMonsterFeildGrid(col, row, grid);</span><br><span class="line">tiles.Grids[col][row] = grid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先需要定义一些砖块类型，然后调用MakeTilesOutlineGrid和MakeTilesMonsterFeildGrid分别用来初始化外边框和内部刷怪的框</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MakeTilesOutlineGrid</span><span class="params">(<span class="keyword">int</span> col, <span class="keyword">int</span> row, <span class="keyword">int</span> grid)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (col == <span class="number">0</span> || col == TILE_H - <span class="number">1</span> || row == <span class="number">0</span> || row == TILE_W - <span class="number">1</span> )&#123; <span class="comment">//边缘 </span></span><br><span class="line">grid = TITLE_TYPE_FRAME;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (col == <span class="number">1</span> || col == TILE_H - <span class="number">2</span> || row == <span class="number">1</span> || row == TILE_W - <span class="number">2</span> ) &#123; <span class="comment">//边缘内一圈</span></span><br><span class="line">grid = TITLE_TYPE_PRORECTED;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> grid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MakeTilesMonsterFeildGrid</span><span class="params">(<span class="keyword">int</span> col, <span class="keyword">int</span> row, <span class="keyword">int</span> grid)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> centerColSize = <span class="number">2</span>; <span class="comment">//出怪点高</span></span><br><span class="line"><span class="keyword">int</span> centerRowSize = <span class="number">3</span>; <span class="comment">//出怪点宽</span></span><br><span class="line"><span class="keyword">if</span> (</span><br><span class="line">col &lt;= TILE_H / <span class="number">2</span> + centerColSize + <span class="number">1</span> &amp;&amp; col &gt;= TILE_H / <span class="number">2</span> - centerColSize - <span class="number">1</span> &amp;&amp;</span><br><span class="line">row &lt;= TILE_W / <span class="number">2</span> + centerRowSize + <span class="number">1</span> &amp;&amp; row &gt;= TILE_W / <span class="number">2</span> - centerRowSize - <span class="number">1</span> <span class="comment">//中心</span></span><br><span class="line">) &#123;</span><br><span class="line">grid = TITLE_TYPE_PRORECTED;</span><br><span class="line"><span class="keyword">if</span> (</span><br><span class="line">col &lt;= TILE_H / <span class="number">2</span> + centerColSize &amp;&amp; col &gt;= TILE_H / <span class="number">2</span> - centerColSize &amp;&amp;</span><br><span class="line">row &lt;= TILE_W / <span class="number">2</span> + centerRowSize &amp;&amp; row &gt;= TILE_W / <span class="number">2</span> - centerRowSize <span class="comment">//中心</span></span><br><span class="line">) &#123;</span><br><span class="line">grid = TITLE_TYPE_ENEMY;</span><br><span class="line"><span class="keyword">if</span> (col == TILE_H / <span class="number">2</span> + centerColSize || col == TILE_H / <span class="number">2</span> - centerColSize ||</span><br><span class="line">row == TILE_W / <span class="number">2</span> + centerRowSize || row == TILE_W / <span class="number">2</span> - centerRowSize) &#123;</span><br><span class="line">grid = TITLE_TYPE_FRAME;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (col == TILE_H / <span class="number">2</span> - centerColSize &amp;&amp; row == TILE_W / <span class="number">2</span>) &#123;</span><br><span class="line">grid = TITLE_TYPE_DOOR;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> grid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们通过grids生成region</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">InitTilesRegion</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> tilesize = <span class="number">18</span>;</span><br><span class="line">COLORREF colors[TITLE_TYPE_CNT] = &#123;</span><br><span class="line">RGB(<span class="number">5</span>, <span class="number">10</span>, <span class="number">5</span>),</span><br><span class="line">RGB(<span class="number">5</span>, <span class="number">150</span>, <span class="number">255</span>),</span><br><span class="line">RGB(<span class="number">5</span>, <span class="number">150</span>, <span class="number">255</span>),</span><br><span class="line">RGB(<span class="number">255</span>, <span class="number">200</span>, <span class="number">50</span>),</span><br><span class="line">RGB(<span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>),</span><br><span class="line">RGB(<span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>),</span><br><span class="line">&#125;;</span><br><span class="line">BOOL fills[TITLE_TYPE_CNT] = &#123;</span><br><span class="line">TRUE,</span><br><span class="line">FALSE,</span><br><span class="line">TRUE,</span><br><span class="line">TRUE,</span><br><span class="line">TRUE,</span><br><span class="line">TRUE,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; TILE_H; col++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; TILE_W; row++) &#123;</span><br><span class="line"><span class="keyword">int</span> grid = tiles.Grids[col][row];</span><br><span class="line">HRGN hrgn = CreateRectRgn(row * tilesize,</span><br><span class="line">col * tilesize,</span><br><span class="line">(row + <span class="number">1</span>) * tilesize,</span><br><span class="line">(col + <span class="number">1</span>) * tilesize);</span><br><span class="line"><span class="keyword">if</span> (tiles.Regions[grid].hBrush == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">tiles.Regions[grid].hBrush = (HBRUSH)CreateSolidBrush(colors[grid]);</span><br><span class="line">tiles.Regions[grid].hrgn = hrgn;</span><br><span class="line">tiles.Regions[grid].fill = fills[grid];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">CombineRgn(tiles.Regions[grid].hrgn, hrgn, tiles.Regions[grid].hrgn, RGN_OR);</span><br><span class="line">DeleteObject(hrgn);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用到CreateRectRgn和CombineRgn分别是用于创建矩形区域和区域合成，CombineRgn最后一个参数RGN_OR表示区域为与上一个区域进行或运算既与上个区域相加。相加完后需要把之前的区域删除掉DeleteObject。<br>注意RGB这个宏用于创建颜色结构，其中三个参数分别是0-255的红绿蓝颜色值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">InitTilesStatic();</span><br><span class="line">InitTilesRegion();</span><br><span class="line">hwnd = CreateWindow(</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>将这两个函数放在CreateWindow之前调用就初始化好了地图的框架。</p><img src="/2021/11/03/win-pac-man-2/frame.png" class="" title="frame"><hr><h4 id="地图障碍物生成"><a href="#地图障碍物生成" class="headerlink" title="地图障碍物生成"></a>地图障碍物生成</h4><p>我们需要在TITLE_TYPE_EMP的区域创建TITLE_TYPE_WALL，可以采用直接写死，也可以采用动态生成。<br>我这边介绍一种动态生成的方式。</p><ul><li>首先生成一个迷宫</li><li>将迷宫明显的死角填补，比如空地周围四个都是墙则视为明显死角。</li></ul><hr><p>生成一个迷宫<br>由于需要易走的迷宫我选择了递归分割法<br>此方法是通过画十字线的方式不断切割地图，同时给十字其中三个轴开口的方式完成迷宫的联通。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">GridsCutBlock</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> top, <span class="keyword">int</span> down, BOOL blocks[TILE_H][TILE_W])</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">blocks[GridsRandOddBlock(top, down)][left] = FALSE; <span class="comment">//在奇数位置开门</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (top == down) &#123;</span><br><span class="line">blocks[top][GridsRandOddBlock(left, right)] = FALSE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">VOID <span class="title">GridsCutBlockRec</span><span class="params">(<span class="keyword">int</span> cutCnt, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> top, <span class="keyword">int</span> down, BOOL blocks[TILE_H][TILE_W])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">VOID <span class="title">GridsCutBlockRec</span><span class="params">(<span class="keyword">int</span> cutCnt, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> top, <span class="keyword">int</span> down, BOOL blocks[TILE_H][TILE_W])</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (left + <span class="number">1</span> &gt;= right || top + <span class="number">1</span> &gt;= down) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//横着画线，在偶数位置画线</span></span><br><span class="line">y = GridsRandEvenBlock(top, down);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt; right; i++) &#123;</span><br><span class="line">blocks[y][i] = TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//竖着画一条线，在偶数位置画线</span></span><br><span class="line">x = GridsRandEvenBlock(left, right);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = top; i &lt; down; i++) &#123;</span><br><span class="line">blocks[i][x] = TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//次数越多迷宫越简单</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cutCnt; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//随机开三扇门，左侧墙壁为0，逆时针旋转</span></span><br><span class="line"><span class="keyword">switch</span> (rand() % <span class="number">4</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">GridsCutBlock(x + <span class="number">1</span>, right, y, y, blocks); <span class="comment">// 2</span></span><br><span class="line">GridsCutBlock(x, x, y + <span class="number">1</span>, down, blocks); <span class="comment">// 3</span></span><br><span class="line">GridsCutBlock(left, x - <span class="number">1</span>, y, y, blocks); <span class="comment">// 4</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">GridsCutBlock(x, x, y + <span class="number">1</span>, down, blocks); <span class="comment">// 3</span></span><br><span class="line">GridsCutBlock(left, x - <span class="number">1</span>, y, y, blocks); <span class="comment">// 4</span></span><br><span class="line">GridsCutBlock(x, x, top, y - <span class="number">1</span>, blocks); <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">GridsCutBlock(left, x - <span class="number">1</span>, y, y, blocks); <span class="comment">// 4</span></span><br><span class="line">GridsCutBlock(x, x, top, y - <span class="number">1</span>, blocks); <span class="comment">// 1</span></span><br><span class="line">GridsCutBlock(x + <span class="number">1</span>, right, y, y, blocks); <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">GridsCutBlock(x, x, top, y - <span class="number">1</span>, blocks); <span class="comment">// 1</span></span><br><span class="line">GridsCutBlock(x + <span class="number">1</span>, right, y, y, blocks); <span class="comment">// 2</span></span><br><span class="line">GridsCutBlock(x, x, y + <span class="number">1</span>, down, blocks); <span class="comment">// 3</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 左上角</span></span><br><span class="line">GridsCutBlockRec(cutCnt, left, x, top, y, blocks);</span><br><span class="line"><span class="comment">// 右上角</span></span><br><span class="line">GridsCutBlockRec(cutCnt, x + <span class="number">1</span>, right, top, y, blocks);</span><br><span class="line"><span class="comment">// 左下角</span></span><br><span class="line">GridsCutBlockRec(cutCnt, left, x, y + <span class="number">1</span>, down, blocks);</span><br><span class="line"><span class="comment">// 右下角</span></span><br><span class="line">GridsCutBlockRec(cutCnt, x + <span class="number">1</span>, right, y + <span class="number">1</span>, down, blocks);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><p>将迷宫明显的死角填补</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">GridsFillCorner</span><span class="params">(BOOL blockes[TILE_H][TILE_W])</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">1</span>; col &lt; TILE_H - <span class="number">1</span>; col++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">1</span>; row &lt; TILE_W - <span class="number">1</span>; row++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!blockes[col][row]) &#123;</span><br><span class="line"><span class="keyword">int</span> crossBlockCnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">-1</span>; y &lt;= <span class="number">1</span>; y++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">-1</span>; x &lt;= <span class="number">1</span>; x++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (x == <span class="number">0</span> || y == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (blockes[col + y][row + x]) &#123;</span><br><span class="line">crossBlockCnt++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (crossBlockCnt &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">blockes[col][row] = TRUE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整理一下函数，同时需要将blockes填入grids</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">InitTilesDynamic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">BOOL blockes[TILE_H][TILE_W] = &#123; FALSE &#125;;</span><br><span class="line">GridsCutBlockRec(<span class="number">3</span>, <span class="number">1</span>, TILE_W - <span class="number">2</span>, <span class="number">1</span>, TILE_H - <span class="number">2</span>, blockes);</span><br><span class="line">GridsFillCorner(blockes);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; TILE_H; col++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; TILE_W; row++) &#123;</span><br><span class="line"><span class="keyword">if</span> (blockes[col][row] &amp;&amp; tiles.Grids[col][row] == TITLE_TYPE_EMP) &#123;</span><br><span class="line">tiles.Grids[col][row] = TITLE_TYPE_WALL;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">VOID <span class="title">InitTiles</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//生成架子</span></span><br><span class="line">InitTilesStatic();</span><br><span class="line"><span class="comment">//随机阻碍</span></span><br><span class="line">InitTilesDynamic();</span><br><span class="line"><span class="comment">//生成region</span></span><br><span class="line">InitTilesRegion();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">srand((<span class="keyword">unsigned</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">InitTiles();</span><br><span class="line">hwnd = CreateWindow(</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里就需要限制只有TITLE_TYPE_EMP的地方能填入TITLE_TYPE_WALL</p><img src="/2021/11/03/win-pac-man-2/done.png" class="" title="done">]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;定义地图结构&quot;&gt;&lt;a href=&quot;#定义地图结构&quot; class=&quot;headerlink&quot; title=&quot;定义地图结构&quot;&gt;&lt;/a&gt;定义地图结构&lt;/h4&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutte</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>windows开发吃豆人——窗口</title>
    <link href="http://example.com/2021/10/31/win-pac-man-1/"/>
    <id>http://example.com/2021/10/31/win-pac-man-1/</id>
    <published>2021-10-31T06:33:35.251Z</published>
    <updated>2021-11-03T06:49:11.595Z</updated>
    
    <content type="html"><![CDATA[<h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>新建一个vc++空项目</p><img src="/2021/10/31/win-pac-man-1/property.png" class="" title="property"><img src="/2021/10/31/win-pac-man-1/system.png" class="" title="system"><p>修改成Windows<br>这一步是用来修改链接的库，否则需要手动添加依赖比较麻烦</p><hr><h4 id="开始编写HelloWorld"><a href="#开始编写HelloWorld" class="headerlink" title="开始编写HelloWorld"></a>开始编写HelloWorld</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">INT WINAPI <span class="title">WinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevinstance, PSTR cmdLine, INT iCmdShow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MessageBox(<span class="literal">NULL</span>, TEXT(<span class="string">&quot;HelloWindows&quot;</span>), TEXT(<span class="string">&quot;Hint&quot;</span>), MB_OK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WinMain是windows程序的入口函数<br>MessageBox第一个参数是父窗口</p><img src="/2021/10/31/win-pac-man-1/hintbox.png" class="" title="hintbox"><hr><h4 id="绘制窗口"><a href="#绘制窗口" class="headerlink" title="绘制窗口"></a>绘制窗口</h4><p>绘制一个窗口需要四个重要的结构<br>WNDCLASS 窗口样式<br>HWND 窗口句柄<br>MSG 事件消息<br>LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM) 事件回调函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> DefWindowProc(hWnd, message, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回调函数主要是处理一些输入和相应事件<br>这里回调暂时可以实现成一个默认过程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INT WINAPI <span class="title">WinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevinstance, PSTR cmdLine, INT iCmdShow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">WNDCLASS wc;</span><br><span class="line">HWND hwnd;</span><br><span class="line">MSG msg;</span><br><span class="line"><span class="keyword">static</span> TCHAR* appName = TEXT(<span class="string">&quot;PacMan&quot;</span>);</span><br><span class="line"><span class="keyword">static</span> TCHAR* wndTitle = TEXT(<span class="string">&quot;吃豆人&quot;</span>);</span><br><span class="line">wc.style = CS_HREDRAW | CS_VREDRAW; <span class="comment">//窗口模式（宽高改变重绘）</span></span><br><span class="line">wc.lpfnWndProc = WndProc; <span class="comment">//窗口事件回调函数</span></span><br><span class="line">wc.hInstance = hInstance; <span class="comment">//窗口实例</span></span><br><span class="line">wc.lpszClassName = appName; <span class="comment">//窗口类名</span></span><br><span class="line">wc.hIcon = LoadIcon(hInstance, IDI_APPLICATION); <span class="comment">//icon样式</span></span><br><span class="line">wc.hCursor = LoadCursor(<span class="literal">NULL</span>, IDC_ARROW); <span class="comment">//鼠标样式</span></span><br><span class="line">wc.hbrBackground = (HBRUSH)GetStockObject(BLACK_BRUSH); <span class="comment">//背景色</span></span><br><span class="line">wc.cbWndExtra = <span class="number">0</span>; <span class="comment">//窗口自定义内容长度</span></span><br><span class="line">wc.cbClsExtra = <span class="number">0</span>; <span class="comment">//窗口类自定义内容长度</span></span><br><span class="line">wc.lpszMenuName = <span class="literal">NULL</span>; <span class="comment">//菜单名</span></span><br><span class="line"><span class="keyword">if</span> (!RegisterClass(&amp;wc)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">hwnd = CreateWindow(</span><br><span class="line">appName,  <span class="comment">//窗口类名</span></span><br><span class="line">wndTitle, <span class="comment">//窗口标题</span></span><br><span class="line">WS_OVERLAPPEDWINDOW, <span class="comment">//窗口样式</span></span><br><span class="line">CW_USEDEFAULT, <span class="comment">//窗口距离屏幕左上角都横坐标</span></span><br><span class="line">CW_USEDEFAULT, <span class="comment">//窗口距离屏幕左上角都纵坐标</span></span><br><span class="line"><span class="number">800</span>, <span class="comment">//窗口宽度</span></span><br><span class="line"><span class="number">640</span>, <span class="comment">//窗口高度</span></span><br><span class="line"><span class="literal">NULL</span>, <span class="comment">//父窗口句柄</span></span><br><span class="line"><span class="literal">NULL</span>, <span class="comment">//菜单句柄</span></span><br><span class="line">hInstance, <span class="comment">//当前实例句柄</span></span><br><span class="line"><span class="literal">NULL</span>); <span class="comment">//指向一个值的指针，该值传递给窗口 WM_CREATE消息。一般为NULL</span></span><br><span class="line">ShowWindow(hwnd, iCmdShow);</span><br><span class="line">UpdateWindow(hwnd);</span><br><span class="line"><span class="keyword">while</span> (GetMessage(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">TranslateMessage(&amp;msg);</span><br><span class="line">DispatchMessage(&amp;msg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> msg.wParam;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里注意WNDCLASS需要所有参数都要初始化才能RegisterClass成功</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (GetMessage(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">TranslateMessage(&amp;msg);</span><br><span class="line">DispatchMessage(&amp;msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>的目的就是不断接受外部的输入来做出反应<br>TranslateMessage用来转换输入成为消息<br>DispatchMessage将消息传入窗口，之后会进入WndProc的回调</p><hr><h4 id="绘制文字"><a href="#绘制文字" class="headerlink" title="绘制文字"></a>绘制文字</h4><p>修改回调</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> TCHAR* text = TEXT(<span class="string">&quot;Hello Windows&quot;</span>);</span><br><span class="line">PAINTSTRUCT ps;</span><br><span class="line">HDC hDC;</span><br><span class="line">RECT rect;</span><br><span class="line"><span class="keyword">switch</span> (message)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> WM_PAINT:</span><br><span class="line">hDC = BeginPaint(hWnd, &amp;ps);</span><br><span class="line">GetClientRect(hWnd, &amp;rect);</span><br><span class="line">DrawText(hDC, text, <span class="number">-1</span>, &amp;rect, DT_SINGLELINE | DT_CENTER | DT_VCENTER);</span><br><span class="line">EndPaint(hWnd, &amp;ps);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">PostQuitMessage(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> DefWindowProc(hWnd, message, wParam, lParam);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里PAINTSTRUCT是画笔，HDC是一个绘画上下文，可以理解成画布，所有东西都绘制在HDC上，RECT则是绘制任何东西都需要的范围，位置和大小。</p><img src="/2021/10/31/win-pac-man-1/window.png" class="" title="window"><hr><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>大写：很多类型通过全大写的方式书写这个是Windows程序的特色</li><li>WINAPI/CALLBACK：区别于普通c程序的地方，这两个都是_stdcall用来修饰函数使其函数栈的回收放在函数使用者，这种修饰下函数不能使用变长参数</li><li>句柄：Windows程序的特色叫法，大部分都是H打头，类似linux程序中的文件，Windows程序的所有数据都被句柄链接，比如一个文本文件，一张图片，一个网络链接，一个窗口，都拥有自己的句柄，操作对应元素的前提都需要获取其句柄。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h4&gt;&lt;p&gt;新建一个vc++空项目&lt;/p&gt;
&lt;img src=&quot;/2021/10/31/win-pac-man-1/property.p</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>puerts-ue开发文本游戏（一）</title>
    <link href="http://example.com/2020/10/28/puerts-ue-text-1/"/>
    <id>http://example.com/2020/10/28/puerts-ue-text-1/</id>
    <published>2020-10-27T17:10:15.100Z</published>
    <updated>2021-11-03T06:49:05.091Z</updated>
    
    <content type="html"><![CDATA[<h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>开发之前首先安装git、nodejs和TypeScrpit，我们需要使用ts来进行开发，装好nodejs后就可以用npm安装ts了，命令行输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g typescript</span><br><span class="line">tsc -v</span><br></pre></td></tr></table></figure><p>正确显示版本后就安装成功了。<br>创建一个ue4的工程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Tencent/puerts.git</span><br></pre></td></tr></table></figure><p>拷贝<code>puerts/unreal/Puerts</code>目录到您项目的Plugins目录下,用文本编辑器修改<code>xxx(项目名).uproject</code>文件，加入Puerts到Plugins，以及JsEnv的依赖</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"> <span class="attr">&quot;Modules&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">      <span class="attr">&quot;AdditionalDependencies&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;CoreUObject&quot;</span>,</span><br><span class="line">        <span class="string">&quot;UMG&quot;</span>,</span><br><span class="line">        <span class="string">&quot;JsEnv&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Engine&quot;</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;Plugins&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;Name&quot;</span>: <span class="string">&quot;Puerts&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;Enabled&quot;</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="UE4的运行流程"><a href="#UE4的运行流程" class="headerlink" title="UE4的运行流程"></a>UE4的运行流程</h4><p>现在就可以使用puerts开发了，在此之前我们先了解一下ue4的一些基本信息。<br>ue4中比较重要的几个概念分别是Engine、GameInstance、WorldContext、World、Level、Actor、GameMode、GameState。<br>简单来讲，他们都是依次包含的，一个ue进程只有一个Engine，里面包含一个GameInstance，可以认为是一个单例，其中包含一个WorldContext，用来记录当前world和level的转换信息和当前的world实例，负责world和level的切换，同一时间只存在一个world，world中包含多个level（编辑器模式），可以理解为不同的关卡的意思，world中记录了当前的level实例，actor作为游戏对象聚合在level中，GameMode和GameState都是world中的单例，GameMode决定关卡的玩法，GameState保留当前关卡的数据。</p><img  src=http://www.plantuml.com/plantuml/svg/VLBBQiCm4BpxAnOV1JxqMeh1XBOKKXfeGi_25ed0NO6aj3Kb_rwzhIMX9zkpixEpinvdRWmCp_nJlAf9m6_JN9fn1TyjjmGzRCMNc0doeVGyEGHWFsZDbuV8OJs4ft65Ce31SBOdfQLTCfJBOHI3ykhm90GxeOqqLg0DG5NPdBKkyAL9Njgx5bZNGOjjDdmFeqBB9PfCwhf-zNK5HWjfnQTGt3W1yMF3fWVFUK5ZEOxEzDitIZpMcEU4BWRxapJ9Pq2SJoheXnB1M_NOcZElsS4GwM1GV_bS2D_h4NwHVSIZH57VakhsKNZhZk5L4xsEcpglKYyZ9ccLJfsE8t2YWtDikvalSUaLYyqvHQfLkyW_vOtvFed_fjF3agka71Fx-cf_><p>实际游戏上几乎可以认为world和level是同等意义的，切换level的时候会销毁world创建新的，这时候就会触发GameMode的init。<br>我们现在需要在一个地方初始化puerts，ue4项目运行后就是一个Engine，但是因为是UEditorEngine，它包含了多个world，可以相互切换，比如刚进入编辑器是Editor类型的World，点击运行就切换成PIE类型的World，所以初始化puerts最好选择GameInstance中。</p><h4 id="开始编写HelloWorld"><a href="#开始编写HelloWorld" class="headerlink" title="开始编写HelloWorld"></a>开始编写HelloWorld</h4><p>新建一个继承于GameInstance的cpp类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;JsEnv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Engine/GameInstance.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;MisenaiBogeinGameInstance.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">UCLASS()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MISENAIBOGEIN_API</span> <span class="title">UMisenaiBogeinGameInstance</span> :</span> <span class="keyword">public</span> UGameInstance</span><br><span class="line">&#123;</span><br><span class="line">    GENERATED_BODY()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnStart</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Shutdown</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TSharedPtr&lt;puerts::FJsEnv&gt; GameScript;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过编辑器新建的文件自动生成了generated.h，手动编写的话需要右击.uproject文件</p><img src="/2020/10/28/puerts-ue-text-1/generate_ue_file.png" class="" title="生成文件"><p>覆盖OnStart和Shutdown</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UMisenaiBogeinGameInstance::OnStart</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GameScript = MakeShared&lt;puerts::FJsEnv&gt;();</span><br><span class="line">    TArray&lt;TPair&lt;FString, UObject*&gt;&gt; args;</span><br><span class="line">    GameScript-&gt;Start(<span class="string">&quot;Entry&quot;</span>, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UMisenaiBogeinGameInstance::Shutdown</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GameScript.Reset();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时运行会报错，需要添加一个名叫Entry的js文件，这里我用TypeScript编写<br>在项目目录执行<code>npm init</code><br>修改package.json的依赖</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="attr">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;@types/react&quot;</span>: <span class="string">&quot;^15.6.6&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;@types/react-reconciler&quot;</span>: <span class="string">&quot;^0.18.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;@types/mocha&quot;</span>: <span class="string">&quot;^7.0.1&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行<code>npm i</code>安装依赖，npm的指令如果太慢可以选择安装cnpm<br>在项目根目录执行<code>tsc --init</code><br>修改这个刚刚生成的tsconfig.json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;target&quot;</span>: <span class="string">&quot;esnext&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;module&quot;</span>: <span class="string">&quot;commonjs&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;jsx&quot;</span>: <span class="string">&quot;react&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;sourceMap&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;typeRoots&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;Content/Typing&quot;</span>,</span><br><span class="line">      <span class="string">&quot;./node_modules/@types&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;outDir&quot;</span>: <span class="string">&quot;Content/Javascript&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;include&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;TSSource/**/*&quot;</span> <span class="comment">//用于存放ts文件的目录</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在项目根目录新建一个TSSource目录用来放ts文件<br>在TSSource目录新建一个Entry.ts</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.warn(<span class="string">&quot;Hello TS UE Warn&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;Hello TS UE Log&quot;</span>);</span><br></pre></td></tr></table></figure><p>然后在项目根目录执行<code>tsc --build</code>将ts翻译成js<br>编译项目，运行</p><img src="/2020/10/28/puerts-ue-text-1/consolelog.png" class="" title="HelloWorld">]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h4&gt;&lt;p&gt;开发之前首先安装git、nodejs和TypeScrpit，我们需要使用ts来进行开发，装好nodejs后就可以用npm安装</summary>
      
    
    
    
    
  </entry>
  
</feed>
